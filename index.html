<!DOCTYPE html>
<html lang="en"><head>
<link rel="icon" href="images/favicon.ico" type="image/x-icon">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<meta name="theme-color" content="#00ffc6">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ BD TRADER PRO KILLER</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e6edf3;
            background: #0a0e1a;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 10% 20%, rgba(28,196,102,.12) 0%, transparent 50%),
                radial-gradient(ellipse at 90% 80%, rgba(46,139,192,.12) 0%, transparent 50%);
            animation: bgShift 15s ease-in-out infinite alternate;
            z-index: -2;
        }

        @keyframes bgShift {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .watermark {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            font-weight: 900;
            color: rgba(28,180,102,.05);
            pointer-events: none;
            animation: rotateWatermark 60s linear infinite;
            z-index: -1;
            letter-spacing: 8px;
        }

        @keyframes rotateWatermark {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .star-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 5s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        header {
            background: linear-gradient(135deg, rgba(15,23,42,.98) 0%, rgba(22,27,34,.98) 100%);
            padding: 20px 30px;
            border-bottom: 3px solid #1cb466;
            box-shadow: 0 4px 30px rgba(28,180,102,.3);
            backdrop-filter: blur(10px);
        }

        header h1 {
            margin: 0 0 15px 0;
            font-size: 32px;
            color: #1cb466;
            text-shadow: 0 0 20px rgba(28,180,102,.6);
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pulse-dot {
            width: 12px;
            height: 12px;
            background: #1cb466;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(28,180,102,.7); }
            50% { box-shadow: 0 0 0 10px rgba(28,180,102,0); }
        }

        .config-boxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .config-input {
            padding: 12px 15px;
            border-radius: 8px;
            border: 2px solid rgba(28,180,102,.3);
            background: rgba(15,23,42,.6);
            color: #e6edf3;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .config-input:focus {
            outline: none;
            border-color: #1cb466;
            box-shadow: 0 0 15px rgba(28,180,102,.3);
        }

        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-size: 11px;
            color: #8b9bab;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        select {
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid rgba(28,180,102,.3);
            background: rgba(15,23,42,.8);
            color: #e6edf3;
            cursor: pointer;
            font-size: 14px;
            min-width: 150px;
            transition: all 0.3s ease;
        }

        select:hover, select:focus {
            border-color: #1cb466;
            box-shadow: 0 0 15px rgba(28,180,102,.2);
            outline: none;
        }

        button {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-toggle {
            background: linear-gradient(135deg, #d33 0%, #8b0000 100%);
            color: #fff;
            box-shadow: 0 4px 15px rgba(221,51,51,.4);
        }

        .btn-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(221,51,51,.6);
        }

        .btn-on {
            background: linear-gradient(135deg, #1cb466 0%, #0d7a3a 100%);
            color: #fff;
            box-shadow: 0 4px 15px rgba(28,180,102,.4);
            animation: glow 2s infinite;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 4px 15px rgba(28,180,102,.4); }
            50% { box-shadow: 0 4px 25px rgba(28,180,102,.8); }
        }

        .btn-on:hover {
            transform: translateY(-2px);
        }

        #sendPartialBtn {
            background: linear-gradient(135deg, #1cb466 0%, #0d7a3a 100%);
            color: #fff;
            box-shadow: 0 4px 15px rgba(28,180,102,.3);
        }

        #sendPartialBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(28,180,102,.5);
        }

        .clock, .countdown {
            font-size: 15px;
            font-weight: 700;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
        }

        .clock {
            color: #00e6e6;
            background: rgba(0,230,230,.1);
            border: 2px solid rgba(0,230,230,.3);
        }

        .countdown {
            color: #ffc107;
            background: rgba(255,193,7,.1);
            border: 2px solid rgba(255,193,7,.3);
            animation: countdownPulse 1s infinite;
        }

        @keyframes countdownPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        main {
            padding: 30px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .table-container {
            background: rgba(15,23,42,.8);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,.3);
            border: 1px solid rgba(28,180,102,.2);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 18px 20px;
            text-align: center;
            border-bottom: 1px solid rgba(28,180,102,.1);
        }

        th {
            background: linear-gradient(135deg, rgba(28,180,102,.2) 0%, rgba(28,180,102,.1) 100%);
            color: #1cb466;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-size: 13px;
        }

        tbody tr {
            transition: all 0.3s ease;
        }

        tbody tr:hover {
            background: rgba(28,180,102,.05);
            transform: scale(1.01);
        }

        .status-pending {
            color: #ffc107;
            font-weight: 700;
            animation: statusBlink 2s infinite;
        }

        @keyframes statusBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-win {
            color: #3fb950;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(63,185,80,.5);
        }

        .status-loss {
            color: #f85149;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(248,81,73,.5);
        }

        .status-mtg-win {
            color: #ffd700;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255,215,0,.5);
        }

        .status-avoid {
            color: #ff8c00;
            font-weight: 700;
        }

        .action-btn {
            cursor: pointer;
            padding: 8px 14px;
            margin: 0 4px;
            border-radius: 6px;
            border: 2px solid;
            background: transparent;
            transition: all .3s ease;
            font-size: 16px;
        }

        .btn-win {
            color: #1cb466;
            border-color: #1cb466;
        }

        .btn-win:hover {
            background: rgba(28,180,102,.2);
            transform: scale(1.1);
        }

        .btn-loss {
            color: #ff4d4d;
            border-color: #ff4d4d;
        }

        .btn-loss:hover {
            background: rgba(255,77,77,.2);
            transform: scale(1.1);
        }

        .btn-mtg {
            color: #ffd700;
            border-color: #ffd700;
        }

        .btn-mtg:hover {
            background: rgba(255,215,0,.2);
            transform: scale(1.1);
        }

        .btn-avoid {
            color: #ff8c00;
            border-color: #ff8c00;
        }

        .btn-avoid:hover {
            background: rgba(255,140,0,.2);
            transform: scale(1.1);
        }

        #supportBtn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 15px 25px;
            background: linear-gradient(135deg, #1cb466 0%, #0d7a3a 100%);
            color: #fff;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(28,180,102,.4);
            font-size: 16px;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        #supportBtn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(28,180,102,.6);
        }

        #popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(15,23,42,.98) 0%, rgba(22,27,34,.98) 100%);
            padding: 40px;
            border: 3px solid #1cb466;
            border-radius: 16px;
            box-shadow: 0 0 50px rgba(28,180,102,.5);
            z-index: 1000;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        #popup p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        #popup button {
            margin-top: 15px;
            padding: 12px 30px;
            background: linear-gradient(135deg, #1cb466 0%, #0d7a3a 100%);
            color: #fff;
        }

        #closePopup {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #e6edf3;
            font-size: 28px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #closePopup:hover {
            color: #f85149;
            transform: rotate(90deg);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(28,180,102,.3);
            border-radius: 50%;
            border-top-color: #1cb466;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 24px;
            }

            .controls {
                justify-content: center;
            }

            th, td {
                padding: 12px 8px;
                font-size: 13px;
            }

            .action-btn {
                padding: 6px 10px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="watermark">BD TRADER PRO</div>
    <div class="star-field"></div>
    
    <div id="popup" style="display: none;">
        <button id="closePopup">√ó</button>
        <p>üéâ Join Our Telegram Channel For Updates</p>
        <a href="https://t.me/SokAlike007trading" target="_blank"><button>Join Now</button></a>
    </div>
    
    <header>
        <h1>
            <span class="pulse-dot"></span>
            üöÄ BD TRADER PRO KILLER
        </h1>
        <div class="config-boxes">
            <input type="text" id="chatId" class="config-input" placeholder="Telegram Chat ID">
            <input type="text" id="botToken" class="config-input" placeholder="Telegram Bot Token">
        </div>
        <div class="controls">
            <div class="control-group">
                <span class="control-label">Market Mode</span>
                <select id="modeSelect">
                    <option value="REAL">Real Market</option>
                    <option value="OTC">OTC Market</option>
                </select>
            </div>
            <div class="control-group">
                <span class="control-label">Trading Asset</span>
                <select id="assetSelect">
                    <option value="ALL">All Assets</option>
                </select>
            </div>
            <div class="control-group">
                <span class="control-label">Direction</span>
                <select id="directionSelect">
                    <option value="BOTH">Both</option>
                    <option value="CALL">CALL</option>
                    <option value="PUT">PUT</option>
                </select>
            </div>
            <button id="toggleBtn" class="btn-toggle">‚èπ Signals OFF</button>
            <div class="control-group">
                <span class="control-label">Language</span>
                <select id="languageSelect">
                    <option value="English">English</option>
                    <option value="Bangla">Bangla</option>
                    <option value="Hindi">Hindi</option>
                    <option value="Urdu">Urdu</option>
                </select>
            </div>
            <button id="sendPartialBtn">üìä Send Partial</button>
            <span class="clock" id="clock"></span>
            <span class="countdown" id="countdown"></span>
        </div>
    </header>
    
    <main>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>‚è∞ Time</th>
                        <th>üí± Pair</th>
                        <th>üéØ Type</th>
                        <th>üìä Status</th>
                        <th>‚ö° Actions</th>
                    </tr>
                </thead>
                <tbody id="signalTable">
                    <tr><td colspan="5" style="padding: 40px; color: #8b9bab;">Waiting for signals...</td></tr>
                </tbody>
            </table>
        </div>
    </main>
    
    <a href="https://t.me/SokAlike007trading" target="_blank"><button id="supportBtn">üìû SUPPORT</button></a>

    <script>
        // No API needed - Everything works locally!

        const OTC_PAIRS = [
            "USD/TRY - OTC", "USD/MXN - OTC", "USD/PKR - OTC", "USD/COP - OTC",
            "USD/BDT - OTC", "USD/PHP - OTC", "USD/DZD - OTC", "USD/BRL - OTC",
            "USD/ARS - OTC", "USD/IDR - OTC", "USD/INR - OTC", "USD/EGP - OTC",
            "USD/NGN - OTC", "BTC/USD - OTC", "ETH/USD - OTC", "XRP/USD - OTC",
            "DOGE/USD - OTC", "LTC/USD - OTC", "Gold/USD - OTC", "Silver/USD - OTC",
            "Brent/USD - OTC", "Microsoft - OTC", "Pfizer - OTC", "Boeing - OTC",
            "Intel - OTC", "McDonald's - OTC", "Johnson & Johnson - OTC",
            "American Express - OTC", "Facebook - OTC"
        ];

        const REAL_PAIRS = [
            "EUR/USD", "EUR/GBP", "GBP/USD", "USD/JPY", "EUR/JPY", "EUR/CAD",
            "EUR/CHF", "AUD/CAD", "CAD/JPY", "USD/CAD", "AUD/JPY", "AUD/USD",
            "GBP/JPY", "NZD/USD", "USD/CHF", "GBP/CAD", "GBP/AUD", "EUR/NZD",
            "AUD/NZD", "USD/MXN", "USD/TRY", "USD/ZAR", "USD/SEK", "USD/NOK", "USD/DKK"
        ];

        let signalsOn = false;
        let signals = [];
        let signalCheckInterval = null;
        let nextSignalCheck = null;

        const translations = {
            English: {
                signalsOff: "‚èπ Signals OFF",
                signalsOn: "‚ñ∂ Signals ON",
                pending: "Pending",
                win: "WIN",
                loss: "LOSS",
                mtgWin: "MTG1 WIN",
                avoid: "AVOID",
                newSignal: (pair, time, dir) => `New signal. Pair: ${pair}, Time: ${time}, Direction: ${dir}.`
            },
            Bangla: {
                signalsOff: "‚èπ ‡¶∏‡¶ø‡¶ó‡¶®‡ßç‡¶Ø‡¶æ‡¶≤ ‡¶Ö‡¶´",
                signalsOn: "‚ñ∂ ‡¶∏‡¶ø‡¶ó‡¶®‡ßç‡¶Ø‡¶æ‡¶≤ ‡¶Ö‡¶®",
                pending: "‡¶™‡ßá‡¶®‡ßç‡¶°‡¶ø‡¶Ç",
                win: "‡¶ú‡¶Ø‡¶º",
                loss: "‡¶π‡¶æ‡¶∞",
                mtgWin: "‡¶è‡¶Æ‡¶ü‡¶ø‡¶ú‡¶ø‡ßß ‡¶ú‡¶Ø‡¶º",
                avoid: "‡¶è‡¶°‡¶º‡¶ø‡¶Ø‡¶º‡ßá ‡¶ö‡¶≤‡ßÅ‡¶®",
                newSignal: (pair, time, dir) => `‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡¶ø‡¶ó‡¶®‡ßç‡¶Ø‡¶æ‡¶≤‡•§ ‡¶ú‡ßã‡¶°‡¶º‡¶æ: ${pair}, ‡¶∏‡¶Æ‡¶Ø‡¶º: ${time}, ‡¶¶‡¶ø‡¶ï: ${dir}.`
            },
            Hindi: {
                signalsOff: "‚èπ ‡§∏‡§ø‡§ó‡•ç‡§®‡§≤ ‡§ë‡§´",
                signalsOn: "‚ñ∂ ‡§∏‡§ø‡§ó‡•ç‡§®‡§≤ ‡§ë‡§®",
                pending: "‡§≤‡§Ç‡§¨‡§ø‡§§",
                win: "‡§ú‡•Ä‡§§",
                loss: "‡§π‡§æ‡§∞",
                mtgWin: "‡§è‡§Æ‡§ü‡•Ä‡§ú‡•Ä‡•ß ‡§ú‡•Ä‡§§",
                avoid: "‡§ü‡§æ‡§≤‡•á‡§Ç",
                newSignal: (pair, time, dir) => `‡§®‡§Ø‡§æ ‡§∏‡§ø‡§ó‡•ç‡§®‡§≤‡•§ ‡§ú‡•ã‡§°‡§º‡§æ: ${pair}, ‡§∏‡§Æ‡§Ø: ${time}, ‡§¶‡§ø‡§∂‡§æ: ${dir}.`
            },
            Urdu: {
                signalsOff: "‚èπ ÿ≥⁄ØŸÜŸÑ ÿ¢ŸÅ",
                signalsOn: "‚ñ∂ ÿ≥⁄ØŸÜŸÑ ÿ¢ŸÜ",
                pending: "ÿ≤€åÿ± ÿßŸÑÿ™Ÿàÿßÿ°",
                win: "ÿ¨€åÿ™",
                loss: "€Åÿßÿ±",
                mtgWin: "ÿß€åŸÖ Ÿπ€å ÿ¨€å€± ÿ¨€åÿ™",
                avoid: "⁄Øÿ±€åÿ≤ ⁄©ÿ±€å⁄∫",
                newSignal: (pair, time, dir) => `ŸÜ€åÿß ÿ≥⁄ØŸÜŸÑ€î ÿ¨Ÿà⁄ëÿß: ${pair}ÿå ŸàŸÇÿ™: ${time}ÿå ÿ≥ŸÖÿ™: ${dir}.`
            }
        };

        function populateAssets() {
            const mode = document.getElementById('modeSelect').value;
            const assetSelect = document.getElementById('assetSelect');
            const pairs = mode === 'REAL' ? REAL_PAIRS : OTC_PAIRS;
            
            assetSelect.innerHTML = '<option value="ALL">All Assets</option>';
            pairs.forEach(pair => {
                const option = document.createElement('option');
                option.value = pair;
                option.textContent = pair;
                assetSelect.appendChild(option);
            });
        }

        populateAssets();
        document.getElementById('modeSelect').addEventListener('change', populateAssets);

        async function fetchSignal() {
            // Generate signal locally - no API needed
            return generateLocalSignal();
        }

        function generateLocalSignal() {
            const mode = document.getElementById('modeSelect').value;
            const asset = document.getElementById('assetSelect').value;
            const direction = document.getElementById('directionSelect').value;
            
            const pairs = mode === 'REAL' ? REAL_PAIRS : OTC_PAIRS;
            let selectedAsset;
            
            if (asset === 'ALL') {
                selectedAsset = pairs[Math.floor(Math.random() * pairs.length)];
            } else {
                selectedAsset = asset;
            }
            
            let selectedDirection;
            if (direction === 'BOTH') {
                selectedDirection = Math.random() > 0.5 ? 'CALL' : 'PUT';
            } else {
                selectedDirection = direction;
            }
            
            const now = new Date();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            
            // Calculate next signal time (every 5 minutes: 00, 05, 10, 15, etc.)
            const nextMinute = (Math.floor(minutes / 5) * 5 + 5) % 60;
            const signalTime = new Date(now);
            
            if (nextMinute === 0) {
                signalTime.setHours(signalTime.getHours() + 1);
            }
            signalTime.setMinutes(nextMinute);
            signalTime.setSeconds(0);
            
            const timeStr = signalTime.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false 
            });
            
            // Calculate time until next signal
            const timeDiff = signalTime.getTime() - now.getTime();
            const nextCheckIn = Math.floor(timeDiff / 1000);
            const nextMins = Math.floor(nextCheckIn / 60);
            const nextSecs = nextCheckIn % 60;
            
            return {
                success: true,
                data: {
                    id: 'signal_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    asset: selectedAsset,
                    time: timeStr,
                    direction: selectedDirection,
                    mode: mode
                },
                nextIn: `${nextMins.toString().padStart(2, '0')}:${nextSecs.toString().padStart(2, '0')}`
            };
        }

        async function sendResultToBackend(signalId, result) {
            // Store locally - no backend needed
            console.log(`Signal ${signalId} result: ${result}`);
            // Results are already tracked in the signals array
        }

        async function sendTelegramMessage(message) {
            const chatId = document.getElementById('chatId').value;
            const botToken = document.getElementById('botToken').value;
            
            if (!chatId || !botToken) {
                console.log('Telegram not configured. Message:', message);
                return;
            }
            
            try {
                // Send directly to Telegram API - no backend needed
                const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        chat_id: chatId, 
                        text: message,
                        parse_mode: 'HTML'
                    })
                });
                
                if (response.ok) {
                    console.log('Telegram message sent successfully');
                } else {
                    console.error('Telegram send failed:', await response.text());
                }
            } catch (error) {
                console.error('Telegram send error:', error);
            }
        }

        function speak(text) {
            const utterance = new SpeechSynthesisUtterance(text);
            const lang = document.getElementById('languageSelect').value;
            utterance.lang = lang === 'Bangla' ? 'bn-BD' : lang === 'Hindi' ? 'hi-IN' : lang === 'Urdu' ? 'ur-PK' : 'en-US';
            speechSynthesis.speak(utterance);
        }

        function addSignalToUI(signal) {
            const trans = translations[document.getElementById('languageSelect').value];
            const tbody = document.getElementById('signalTable');
            
            if (tbody.querySelector('td[colspan="5"]')) {
                tbody.innerHTML = '';
            }
            
            const row = document.createElement("tr");
            row.dataset.signalId = signal.id;
            row.innerHTML = `
                <td><strong>${signal.time}</strong></td>
                <td><strong>${signal.asset}</strong></td>
                <td style="color: ${signal.direction === 'CALL' ? '#3fb950' : '#f85149'}"><strong>${signal.direction}</strong></td>
                <td class="status-pending">${trans.pending}</td>
                <td>
                    <button class="action-btn btn-win">‚úÖ</button>
                    <button class="action-btn btn-loss">‚ùå</button>
                    <button class="action-btn btn-mtg">‚ôªÔ∏è</button>
                    <button class="action-btn btn-avoid">‚ö†Ô∏è</button>
                </td>
            `;
            
            const statusCell = row.querySelector("td:nth-child(4)");
            const buttons = row.querySelectorAll("button");
            
            buttons.forEach(btn => {
                btn.addEventListener("click", async (e) => {
                    const type = e.target.classList.contains("btn-win") ? "win" :
                                 e.target.classList.contains("btn-loss") ? "loss" :
                                 e.target.classList.contains("btn-mtg") ? "mtg" : "avoid";
                    
                    statusCell.textContent = type === "win" ? trans.win :
                                             type === "loss" ? trans.loss :
                                             type === "mtg" ? trans.mtgWin : trans.avoid;
                    statusCell.className = `status-${type === 'mtg' ? 'mtg-win' : type}`;
                    
                    await sendResultToBackend(signal.id, type);
                    
                    let resultMessage = "";
                    if (type === "win") {
                        resultMessage = `‚úÖ SURESHOT WIN ‚û§ ${signal.asset} ${signal.time}`;
                    } else if (type === "loss") {
                        resultMessage = `‚ùå LOSS ‚û§ ${signal.asset} ${signal.time}`;
                    } else if (type === "mtg") {
                        resultMessage = `‚ôªÔ∏è MTG1 WIN ‚û§ ${signal.asset} ${signal.time}`;
                    } else if (type === "avoid") {
                        resultMessage = `‚ö†Ô∏è AVOID TRADE ‚û§ ${signal.asset} ${signal.time}`;
                    }
                    
                    if (resultMessage) {
                        await sendTelegramMessage(resultMessage);
                    }
                    
                    buttons.forEach(b => b.disabled = true);
                    
                    const sig = signals.find(s => s.id === signal.id);
                    if (sig) sig.status = type;
                });
            });
            
            tbody.prepend(row);
            
            if (tbody.children.length > 20) {
                tbody.removeChild(tbody.lastChild);
            }
            
            speak(trans.newSignal(signal.asset, signal.time, signal.direction));
            
            const message = `‚ö°Ô∏èBD TRADER KILLER‚ö°Ô∏è
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ôî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
üöÄAsset         ‚òû ${signal.asset}
‚è∞Time          ‚òû ${signal.time}
‚è≥Expiration ‚òû M1
üéØDirection   ‚òû ${signal.direction === 'CALL' ? 'üü¢CALL' : 'üî¥PUT'}
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ôî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
üí• Good Lucküí•`;
            
            sendTelegramMessage(message);
            signals.push({ ...signal, status: 'pending' });
        }

        async function checkForSignal() {
            if (!signalsOn) return;
            
            const result = await fetchSignal();
            
            if (result && result.success && result.data) {
                addSignalToUI(result.data);
                
                if (result.nextIn) {
                    const [mins, secs] = result.nextIn.split(':').map(Number);
                    const nextCheckMs = (mins * 60 + secs) * 1000;
                    
                    nextSignalCheck = Date.now() + nextCheckMs;
                    startCountdown();
                    
                    signalCheckInterval = setTimeout(checkForSignal, nextCheckMs);
                }
            } else {
                if (result && result.nextIn) {
                    const [mins, secs] = result.nextIn.split(':').map(Number);
                    const nextCheckMs = (mins * 60 + secs) * 1000;
                    
                    nextSignalCheck = Date.now() + nextCheckMs;
                    startCountdown();
                    
                    signalCheckInterval = setTimeout(checkForSignal, nextCheckMs);
                } else {
                    signalCheckInterval = setTimeout(checkForSignal, 5000);
                }
            }
        }

        function startCountdown() {
            const countdownEl = document.getElementById('countdown');
            
            const updateCountdown = () => {
                if (!nextSignalCheck || !signalsOn) {
                    countdownEl.textContent = '';
                    return;
                }
                
                const remaining = Math.max(0, Math.floor((nextSignalCheck - Date.now()) / 1000));
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                
                countdownEl.textContent = `Next: ${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                
                if (remaining > 0 && signalsOn) {
                    requestAnimationFrame(updateCountdown);
                }
            };
            
            updateCountdown();
        }

        function stopSignals() {
            signalsOn = false;
            if (signalCheckInterval) {
                clearTimeout(signalCheckInterval);
                signalCheckInterval = null;
            }
            nextSignalCheck = null;
            document.getElementById('countdown').textContent = '';
        }

        function updateClock() {
            document.getElementById('clock').textContent = new Date().toLocaleTimeString();
        }

        function createStarField() {
            const starField = document.querySelector('.star-field');
            starField.innerHTML = '';
            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = star.style.height = `${Math.random() * 2 + 1}px`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.left = `${Math.random() * 100}%`;
                star.style.animationDelay = `${Math.random() * 5}s`;
                starField.appendChild(star);
            }
        }

        document.getElementById('closePopup').addEventListener('click', () => {
            document.getElementById('popup').style.display = 'none';
        });

        // Show welcome popup and initialize on page load
        window.addEventListener('load', () => {
            document.getElementById('popup').style.display = 'block';
            createStarField();
        });

        document.getElementById('toggleBtn').addEventListener('click', () => {
            const trans = translations[document.getElementById('languageSelect').value];
            signalsOn = !signalsOn;
            const btn = document.getElementById('toggleBtn');
            
            if (signalsOn) {
                btn.textContent = trans.signalsOn;
                btn.className = 'btn-on';
                checkForSignal();
            } else {
                btn.textContent = trans.signalsOff;
                btn.className = 'btn-toggle';
                stopSignals();
            }
        });

        document.getElementById('sendPartialBtn').addEventListener('click', () => {
            let winCount = 0, mtgCount = 0, lossCount = 0, avoidCount = 0;
            
            const lines = signals.map(sig => {
                let emoji = "";
                let direction = sig.direction === 'CALL' ? 'ùô±ùöÑùöà' : 'ùôøùöÑùöÉ';
                
                if (sig.status === "win") { 
                    emoji = "‚úÖ"; 
                    winCount++; 
                } else if (sig.status === "mtg") { 
                    emoji = "‚úÖ."; 
                    mtgCount++; 
                } else if (sig.status === "loss") { 
                    emoji = "‚úñÔ∏è"; 
                    lossCount++; 
                } else if (sig.status === "avoid") { 
                    emoji = "‚ö†Ô∏è"; 
                    avoidCount++; 
                } else {
                    emoji = "‚è≥";
                }
                
                // Format: USDEGP-OTC (remove space and slash)
                const formattedAsset = sig.asset.replace('/', '').replace(' - ', '-');
                
                return `‚ùí ${formattedAsset} ‚òû ${sig.time} ‚ä± ${direction}${emoji}`;
            }).join('\n');
            
            const totalSignals = signals.length;
            const totalWins = winCount + mtgCount;
            const winRate = totalSignals > 0 ? Math.round((totalWins / totalSignals) * 100) : 0;
            
            const message = `======== ùôøùô∞ùöÅùöÉùô∏ùô∞ùôª ùöÅùô¥ùöÇùöÑùôªùöÉ ========

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„Éª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
                       ‚ú™ùôøùô∞ùô∏ùöÅùöÇ‚ú™
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„Éª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${lines}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„Éª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ ùôΩùôæùôΩ ùôºùöÉùô∂: ${winCount}
‚úÖ ùôºùöÉùô∂ ùü∑     : ${mtgCount}
‚ö†Ô∏è ùô∞ùöÖùôæùô∏ùô≥    : ${avoidCount < 10 ? '0' + avoidCount : avoidCount}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„Éª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üéØ ùêìùê®ùê≠ùêöùê• ùêíùê¢ùê†ùêßùêöùê•ùê¨: ${totalWins}x${lossCount}(${winRate}%)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„Éª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;
            
            sendTelegramMessage(message);
        });

        setInterval(updateClock, 1000);
        updateClock();
    </script>
    <script>
        // This script is for preventing right-click, etc. and does not need changes.
        (function(){
          const allowedInputs = ['chatId', 'botToken'];
          function isAllowedTarget(el){ if(!el) return false; try{ if(el.id && allowedInputs.includes(el.id)) return true; const tag = el.tagName && el.tagName.toLowerCase(); if(tag === 'input' || tag === 'textarea') return true; if(el.isContentEditable) return true; if(el.closest && el.closest('input, textarea, [contenteditable="true"]')) return true; }catch(e){} return false; }
          function stopEvent(e){ try{ e.stopImmediatePropagation(); }catch(_){}; try{ e.preventDefault(); }catch(_){}; return false; }
          window.addEventListener('contextmenu', function(e){ if(isAllowedTarget(e.target)) return; stopEvent(e); }, true);
          window.addEventListener('mousedown', function(e){ if(isAllowedTarget(e.target)) return; if(e.button === 2) stopEvent(e); }, true);
          window.addEventListener('selectstart', function(e){ if(isAllowedTarget(e.target)) return; stopEvent(e); }, true);
          window.addEventListener('dragstart', function(e){ if(isAllowedTarget(e.target)) return; stopEvent(e); }, true);
          ['copy','cut','paste'].forEach(ev => { window.addEventListener(ev, function(e){ if(isAllowedTarget(e.target)) return; stopEvent(e); }, true); });
          window.addEventListener('keydown', function(e){ const active = document.activeElement; if(isAllowedTarget(active)) return; const key = (e.key || '').toLowerCase(); if(e.key === 'F12' || e.keyCode === 123){ stopEvent(e); return; } const ctrl = e.ctrlKey || e.metaKey; const shift = e.shiftKey; if(ctrl && !shift && (key === 'u' || key === 's' || key === 'p' || key === 'a')){ stopEvent(e); return; } if(ctrl && shift && (key === 'i' || key === 'j' || key === 'c' || key === 's' || key === 'p' || key === 'k')){ stopEvent(e); return; } if(ctrl && (key === 'f' || key === 'r' || key === 'w')){ stopEvent(e); return; } if(e.keyCode === 73 && ctrl && shift) { stopEvent(e); return; } if((e.altKey && ctrl) && (key === 'i' || key === 'j')){ stopEvent(e); return; } }, true);
          let touchTimer = null; window.addEventListener('touchstart', function(e){ if(isAllowedTarget(e.target)) return; if(e.touches && e.touches.length === 1){ touchTimer = setTimeout(function(){}, 600); } }, {passive:false}); window.addEventListener('touchend', function(e){ if(isAllowedTarget(e.target)) return; if(touchTimer){ clearTimeout(touchTimer); touchTimer = null; } });
          const origExec = Document.prototype.execCommand; try { Document.prototype.execCommand = function(cmd){ const active = document.activeElement; if(isAllowedTarget(active)) return origExec.call(this, cmd); return false; }; } catch(e){}
          try { const mo = new MutationObserver(function(muts){ muts.forEach(m => { if(m.type === 'attributes' && m.target){ const t = m.target; if(isAllowedTarget(t) && t.hasAttribute('disabled')) t.removeAttribute('disabled'); } }); }); mo.observe(document.documentElement || document.body, {attributes:true, subtree:true}); } catch(e){}
          window.__bd_protection_active = true;
        })();
    </script>

</body>
</html>
